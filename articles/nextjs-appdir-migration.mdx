---
title: 'Migrating your Next.js application to `appDir`'
date: 2023-04-19T10:00:00.000Z
description: 'Learn how to migrate your Next.js application to the new `appDir` feature. This guide will help you to understand the new Next.js features and how to migrate your application in a "safe" way.'
tags:
  - nextjs
  - appDir
  - migration
  - javascript
  - react
  - router
  - seo
  - api
  - vercel
image: '/images/articles/nextjs-appdir-migration/cover.png'
author:
  name: Mateo
  image: '/images/profile.png'
---

<Image
  src="/images/articles/nextjs-appdir-migration/cover.png"
  width="1280"
  height="720"
  alt="Migrating your Next.js application to appDir"
  href="/blog/nextjs-appdir-migration"
/>

Hi folks! üëã

Today I finally finished the migration of Next.js to the new `router` and the new experimental features of version 13. I've merged this [PR](https://github.com/mateonunez/website/pull/209) that contains all the changes I've made to migrate my website to the new features. I have to admit: it was so funny to do it! üòÑ

The migration was not so hard, the [beta](https://beta.nextjs.org/docs) documentation is really good and the core concepts are explained in a very clear way.

Next.js 13 introduced the new App Router built on top of **React Server Components** with support for layouts, nested routing, loading states, error handling, and more

Let's see what are the new features and how to migrate your application to the new `appDir` feature.

In this article, I will talk about:

- <a href="#what-is-appdir">
    What is <b>appDir</b>?
  </a>
- <a href="#the-metadata-object">
    The <b>metadata</b> object
  </a>
- <a href="#new-api-routes">
    New API routes
  </a>
- <a href="#the-use-client-directive">
    The <b>use client</b> directive
  </a>

## <a name="what-is-appdir" /> What is `appDir`?

> The new App Router works in a new directory named app. The app directory works alongside the pages directory to allow for incremental adoption. This allows you to opt some routes of your application into the new behavior while keeping other routes in the pages directory for previous behavior.
> \- [Next.js documentation](https://beta.nextjs.org/docs/routing/fundamentals#the-app-directory)

<Row>
  <Column>
    <h3>`appDir` structure</h3>
    <Image
      src="/images/articles/nextjs-appdir-migration/apptree.png"
      width="334"
      height="485"
      alt="Next.js pages dir migration to appDir"
    />
  </Column>
  <Column>
    <h3>`pages` structure</h3>
    <Image
      src="/images/articles/nextjs-appdir-migration/pagestree.png"
      width="334"
      height="485"
      alt="Next.js pages dir migration to appDir"
    />
  </Column>
</Row>

One of the main changes with the new *appDir* is that by default, all the components inside `app` are [React Server Components](https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components). This means that the components inside `app` will be rendered in the server and the client will receive the HTML generated by the server.

> You can use the <a href="#the-use-client-directive">'use-client' directive</a> to render a component in the client only.

### Before starting

Before starting the migration, I recommend you to read the [Next.js documentation](https://beta.nextjs.org/docs) about the new features and the [migration guide](https://nextjs.org/docs/upgrading#migrating-from-v12-to-v13) to understand the changes.

Let's see some terminology used in the documentation:

- **Tree**: A convention for visualizing a hierarchical structure. For example, a component tree with parent and children components, a folder structure, etc.
- **Subtree**: Part of a tree, starting at a new root (first) and ending at the leaves (last).
- **Root**: The first node in a tree or subtree, such as a root layout.
- **Leaf**: Nodes in a subtree that have no children, such as the last segment in a URL path.

Let's the difference between the `app` and `pages` directories:

- `layout.js`
  - The **layout** is the root of the subtree. It is the first component that is rendered in the server and the client. It is the parent of all the other components in the subtree. It allows you to define the layout (header, footer, etc) of the **subtree**.
  - You can define a **layout** for all the subtree or for a specific route or a group of routes (tree, subtree, etc).

    `RootLayout.js`, in this website I've defined a `RootLayout` component that is the parent of all the other components in the subtree. This component is defined in the `app` directory and it is rendered in the server and the client.

    ```jsx
    ...
    export const metadata = meta;

    export default function RootLayout({ children }) {
      return (
        <html lang="en">
          <head>
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="author" content="mateonunez" />
            <meta name="theme-color" content="#F59E0B" />
          </head>

          <body className="antialiased">
            <UIProvider>
              <MainLayout>
                <Suspense fallback={<Loading />}>{children}</Suspense>
              </MainLayout>
            </UIProvider>
          </body>
        </html>
      );
    }
  ```

- `error.js`
  - The **error** component is rendered when an error occurs in the subtree. It is the last component that is rendered in the server and the client.
  - You can define an **error** component for all the subtree or for a specific route or a group of routes (tree, subtree, etc).

  This file replaced my old `400.jsx` and `500.jsx` files with a generic `error.js` file.

  ```jsx
  export default function Eror({ error, reset }) {
    useEffect(() => {
      console.error(error);
    }, [error]);

    return (
      <>
        <div className={s.root}>
          <h2 className="title">Error unexpected. Can you fix me?</h2>

          <button onClick={() => reset()}>Try again</button>
        </div>
      </>
    );
  }
  ```
  > You can custom the error page for each subtree. For example, you can define a custom error page for the `blog` subtree and another custom error page for the `about` subtree.

- `loading.js`
  - The **loading** component is rendered when the subtree is loading. It is the last component that is rendered in the server and the client.
  - You can define a **loading** component for all the subtree or for a specific route or a group of routes (tree, subtree, etc).

  ```jsx
  export default function Loading() {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="w-32 h-32 border-b-2 border-gray-300 rounded-full animate-spin"></div>
      </div>
    );
  }
  ```
- `page.js`
  - The **page** component is the last component that is rendered in the server and the client. It is the leaf of the subtree.
  - You can define a **page** component for all the subtree or for a specific route or a group of routes (tree, subtree, etc).
  - You can define a **page** component for a specific route or a group of routes (tree, subtree, etc).

With what we said earlier in mind, the structure of the new `appDir` begins to make a little more sense.

We have a `layout` that can be defined for all the subtree (or not), a `loading` component that is rendered when the subtree is loading, an `error` component, and a `page` component that is the leaf of the subtree.

### How are slug pages handled?

The new `appDir` allows you to define a `page` component for a specific route or a group of routes (tree, subtree, etc).

For example, if you have a `blog` subtree, you can define a `page` component for all the routes inside the `blog` subtree. This `page` component will be rendered for all the routes inside the `blog` subtree.

```jsx
// app/blog/page.jsx
export default function BlogPage({ children }) {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen py-2">
      <main className="flex flex-col items-center justify-center w-full flex-1 px-20 text-center">
        <h1 className="text-6xl font-bold">Blog</h1>
        <p className="mt-3 text-2xl">My blog posts</p>
        {children}
      </main>
    </div>
  );
}

// app/blog/[slug]/page.jsx
export default function BlogPostPage({ children }) {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen py-2">
      <main className="flex flex-col items-center justify-center w-full flex-1 px-20 text-center">
        <h1 className="text-6xl font-bold">Blog</h1>
        <p className="mt-3 text-2xl">My blog posts</p>
        {children}
      </main>
    </div>
  );
}
```

## <a name="the-metadata-object" /> The **metadata** object?

This is one of my favorite features of the new Next.js version. It allows you to define a `metadata` object for each subtree. This object is used to define the `title`, `description`, `image`, `url`, `type`, `locale`, `site_name`, `twitter`, and `facebook` of the subtree (or tree), avoiding external libraries or custom code.

This is an example of my default `metadata` object:

```jsx
import config from './index';
const author = {
  name: 'Mateo Nunez',
  twitter: '@mateonunez95',
  github: '@mateonunez',
  email: 'mateonunez95@gmail.com',
  website: 'https://mateonunez.dev'
};

const defaultTitle = '@mateonunez';
const defaultDescription =
  "Hi folks! I'm Mateo Nunez, a Software Engineer from Colombia based in Milan. I ‚ù§Ô∏è Open Source, JavaScript, the music, the food, the challenges and the continous improvement.";

const metadata = {
  title: {
    template: '%s | @mateonunez',
    default: defaultTitle
  },
  description: defaultDescription,
  keywords: [
    'mateo nunez',
    'mateonunez',
    'software engineer',
    'open source',
    'javascript',
    'nodejs',
    'react'
  ],
  author,
  authors: [author],
  colorSchema: 'dark',
  metadataBase: new URL(config.baseUrl),
  openGraph: {
    title: defaultTitle,
    description: defaultDescription,
    url: config.baseUrl,
    sitename: defaultTitle,
    images: [
      {
        url: 'https://mateonunez.dev/card.png',
        width: 512,
        height: 512,
        alt: 'Mateo Nunez'
      }
    ],
    locale: 'en_US',
    type: 'website'
  },
  icons: {
    icon: '/favicon-16x16.png',
    shortcut: '/favicon.ico',
    apple: '/apple-touch-icon.png'
  },
  themeColor: '#F59E0B',
  manifest: '/site.webmanifest',
  twitter: {
    card: 'summary_large_image',
    title: `${defaultTitle} on Twitter`,
    description: defaultDescription,
    creator: '@mateonunez95'
  },
  viewport: {
    width: 'device-width',
    initialScale: 1,
    maximumScale: 5
  }
};

export default metadata;
```

And this is an example of how to use it:

```jsx
// app/layout.jsx
import metadata from './metadata';

export const metadata = meta;

export default function RootLayout({ children }) {
  ...
}
```

The implementation of the `metadata` object inside the root layout means that all the subtree will inherit the `metadata` object until you define a new `metadata` object for a specific route or a group of routes (tree, subtree, etc).

```jsx
// app/blog/page.jsx
import meta from './metadata';
export const metadata = {
  title: '> blog',
  description: `Articles written with ‚ù§Ô∏è by ${meta.author.name} and the Community. ${meta.description}`,
  keywords: [...meta.keywords, 'blog', 'articles']
};

export default function Blog() {
  ...
}
```

### <a name="generate-dynamic-metadata" /> Generate dynamic metadata

It's also possible to generate dynamic metadata for a specific route or a group of routes (tree, subtree, etc) by using the `generateMetadata` function.

```jsx
// app/blog/[slug]/page.jsx
export async function generateMetadata({ params }) {
  const { slug } = params;
  const { frontMatter } = await getArticle({ slug });

  return {
    ...meta,
    title: frontMatter.title,
    description: frontMatter.description,
    keywords: frontMatter.tags,
    openGraph: {
      title: frontMatter.title,
      description: frontMatter.description,
      type: 'article',
      article: {
        authors: [frontMatter.author.name],
        tags: frontMatter.tags,
        publishedTime: frontMatter.date,
        modifiedTime: frontMatter.date
      },
      images: [
        {
          url: urlJoin(config.baseUrl, frontMatter.image),
          alt: frontMatter.title
        }
      ]
    }
  };
}
```

Generating dynamic metadata is useful when you want to define a `metadata` object for a specific route or a group of routes (tree, subtree, etc) that depends on the route params.


